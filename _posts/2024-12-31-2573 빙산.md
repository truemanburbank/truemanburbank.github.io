---
title: 2573 ë¹™ì‚°
date: 2024-12-31
categories: [Boj, C++]
tags: [BFS]
---
# ë¬¸ì œ ë§í¬

[](https://www.acmicpc.net/problem/2573)

# ì ‘ê·¼

<aside>
ğŸ’¡

ë°°ì—´ì—ì„œ ë¹™ì‚°ì˜ ê° ë¶€ë¶„ì— í•´ë‹¹ë˜ëŠ” ì¹¸ì— ìˆëŠ” ë†’ì´ëŠ” ì¼ë…„ë§ˆë‹¤ ê·¸ ì¹¸ì— ë™ì„œë‚¨ë¶ ë„¤ ë°©í–¥ìœ¼ë¡œ ë¶™ì–´ìˆëŠ” 0ì´ ì €ì¥ëœ ì¹¸ì˜ ê°œìˆ˜ë§Œí¼ ì¤„ì–´ë“ ë‹¤. 

</aside>

- ì‹œê°„ ì œí•œì€ 1ì´ˆì´ê³ , N, Mì€ 3 ì´ìƒ, 300 ì´í•˜ì´ë‹¤.
- ë°°ì—´ì—ì„œ ë¹™ì‚°ì´ ì°¨ì§€í•˜ëŠ” ì¹¸ì˜ ê°œìˆ˜, ì¦‰, 1 ì´ìƒì˜ ì •ìˆ˜ê°€ ë“¤ì–´ê°€ëŠ” ì¹¸ì˜ ê°œìˆ˜ëŠ” 10,000 ê°œ ì´í•˜ì´ë‹¤. â†’ ë­”ê°€ ì¡°ê±´ì„ ì¹˜ë©´ ë‹¨ìˆœ íƒìƒ‰ì„ í•´ë„ ë  ê²ƒ ê°™ë‹¤.

# ì‹œê°„ ë³µì¡ë„

ë¹™í•˜ë¥¼ íƒìƒ‰í•˜ëŠ” ì‹œê°„ ë³µì¡ë„ëŠ” ë°°ì—´ ì „ì²´ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ë¹™í•˜(1 ì´ìƒì˜ ì •ìˆ˜ë¡œ í‘œí˜„ëœ ì¹¸)ë¥¼ íƒìƒ‰í•˜ê±°ë‚˜, DFS ë˜ëŠ” BFSë¥¼ ì´ìš©í•˜ì—¬ ì—°ê²°ëœ ë¹™í•˜ ì˜ì—­ì„ íƒìƒ‰í•˜ëŠ” ê²½ìš°ë¥¼ ê³ ë ¤í•´ì•¼ í•œë‹¤.

1. **ë°°ì—´ ìˆœíšŒ** O(NÃ—M)
    
    ë°°ì—´ í¬ê¸°ëŠ” **NÃ—M**ì´ë©°, ìµœì•…ì˜ ê²½ìš° ë°°ì—´ ì „ì²´ë¥¼ ìˆœíšŒí•´ì•¼ í•œë‹¤. ë”°ë¼ì„œ ìˆœíšŒì— ê±¸ë¦¬ëŠ” ì‹œê°„ì€ **O(NÃ—M)**ì´ë‹¤.
    
2. **DFS ë˜ëŠ” BFS íƒìƒ‰** O(ë¹™í•˜Â ì¹¸Â ìˆ˜)=O(10,000)
    
    ë¹™í•˜ê°€ ìµœëŒ€ 10,000ê°œì˜ ì¹¸ì„ ì°¨ì§€í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë¹™í•˜ íƒìƒ‰ì—ì„œ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ì¹¸ì˜ ê°œìˆ˜ëŠ” ìµœëŒ€ 10,000ê°œì´ë‹¤. íƒìƒ‰í•  ë•Œë§ˆë‹¤ íƒìƒ‰í•œ ê³³ì€ ê±´ë„ˆë›°ë¯€ë¡œ, ë§¤ë²ˆ íƒìƒ‰ì‹œ ë§ˆë‹¤ 10000ì¹¸ì„ ë‹¤ ë„ëŠ” ê²ƒì´ ì•„ë‹ˆë‹¤.
    
    DFS/BFSì˜ ì‹œê°„ ë³µì¡ë„ëŠ” ë°©ë¬¸í•œ ë…¸ë“œ ìˆ˜ì— ë¹„ë¡€í•˜ë¯€ë¡œ **O(ë¹™í•˜Â ì¹¸Â ìˆ˜) = O(10,000)**
    
3. **ìµœì•…ì˜ ê²½ìš° ì „ì²´ ì‹œê°„ ë³µì¡ë„**O(NÃ—M+10,000)
    
    ë°°ì—´ ì „ì²´ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ê° ë¹™í•˜ ì¹¸ì—ì„œ DFS/BFSë¥¼ í˜¸ì¶œí•œë‹¤ë©´, ìµœì•…ì˜ ì‹œê°„ ë³µì¡ë„ëŠ” **O(NÃ—M+10,000)**
    
    ê·¸ëŸ¬ë‚˜, **O(NÃ—M)**ì´ ì§€ë°°ì ì´ë‹¤.
    

### ìµœì¢… ì‹œê°„ ë³µì¡ë„

**O(NÃ—M) â†’ O(NÃ—MÃ—T)**

# 1. water ë°°ì—´ì„ ë§Œë“¤ì–´ í•´ë‹¹ ìœ„ì¹˜ì— ë¬¼ì— ì–¼ë§ˆë§Œí¼ ë‘˜ëŸ¬ìŒ“ì—¬ìˆëŠ”ì§€ ê°’ì„ ì €ì¥í•œë‹¤.

BFSë¥¼ í•´ì„œ ìƒ, í•˜, ì¢Œ, ìš°ë¥¼ ì‚´í•€ ë‹¤ìŒ, 0ì´ ìˆìœ¼ë©´ Countë¥¼ ì¦ê°€ì‹œí‚¨ë‹¤. ë‹¤ìŒ water ë°°ì—´ì— ì €ì¥í•œë‹¤. ì´ë•Œ ë¹™í•˜ê°€ ì´ë¯¸ ë‘ ë©ì–´ë¦¬ ì´ìƒì¸ì§€ ê²€ì‚¬í•˜ì—¬ íŒë‹¨í•œë‹¤.

# 2. ì‹œê°„ì´ ì§€ë‚œ ë’¤ ë¹™í•˜ë¥¼ íƒìƒ‰í•˜ì—¬ ë©ì–´ë¦¬ê°€ ëª‡ ê°œ ìˆëŠ”ì§€ ê²€ì‚¬í•œë‹¤.

waterì—ì„œ êµ¬í•œ ì¸ì ‘í•œ ë¬¼ì˜ ê°œìˆ˜ë¥¼ ë¹™í•˜ì˜ ê¸¸ì´ì— ë¹¼ì¤€ë‹¤.

# 3. 1-2ë¥¼ ë°˜ë³µí•œë‹¤.

# ì½”ë“œ

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;

const int MAX = 300 + 1;

int dirX[4] = {-1, 0, 1, 0};
int dirY[4] = {0, 1, 0, -1};

int map[MAX][MAX];
int visited[MAX][MAX];
int waterVisited[MAX][MAX];
int water[MAX][MAX];

int N, M;

void CalcAdjacentWater()
{
    queue<pair<int, int>> q;
    q.push({0, 0});
    waterVisited[0][0] = 1;
    while (!q.empty())
    {
        pair<int, int> cur = q.front();
        int count = 0;
        q.pop();

        for (int i = 0; i < 4; i++)
        {
            int x = cur.first + dirX[i];
            int y = cur.second + dirY[i];

            if (map[x][y] == 0)
                count++;
            
            if (x < 0 || x >= MAX || y < 0 || y >= MAX) continue;
            if (waterVisited[x][y] == 1) continue;

            q.push({x, y});
            waterVisited[x][y] = 1;
        }
        water[cur.first][cur.second] = count;
    }
    memset(waterVisited, 0, sizeof(waterVisited));
}

void TimePass()
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            if (map[i][j] > 0)
            {
                map[i][j] -= water[i][j];
                map[i][j] = max(0, map[i][j]);
            }
        }
    }
}

void bfs(int x, int y)
{
    queue<pair<int, int>> q;
    q.push({x, y});
    visited[x][y] = 1;

    while (!q.empty())
    {
        pair<int, int> cur = q.front();
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            int nx = cur.first + dirX[i];
            int ny = cur.second + dirY[i];

            if (nx < 0 || nx >= MAX || ny < 0 || ny >= MAX) continue;
            if (visited[nx][ny] == 1 || map[nx][ny] == 0) continue;

            q.push({nx, ny});
            visited[nx][ny] = 1;
        }
    }
}

bool checkZero()
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
        {
            if (map[i][j] > 0) return false;
        }
    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> N >> M;

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            cin >> map[i][j];
        }
    }
    
    int year = 0;
    while (true)
    {
        if (checkZero())
        {
            cout << 0;
            return 0;
        }
        int count = 0;
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                if (visited[i][j] == 1 || map[i][j] == 0)
                    continue;
                bfs(i, j);
                count++;
            }
        }

        if (count > 1) break;
        
        CalcAdjacentWater();
        TimePass();
        memset(visited, 0, sizeof(visited));
        year++;
    }

    cout << year;
    return 0;
}

```

![image](https://github.com/user-attachments/assets/5c3c899b-1f35-4013-bf62-ee429d4b761b)


# ì‹œê°„ì´ ë” íš¨ìœ¨ì ì¸ ì½”ë”©

[ë°”í‚¹ë…ë‹˜ì˜ ì½”ë“œ](https://github.com/encrypted-def/basic-algo-lecture/blob/master/0x09/solutions/2573.cpp)

```cpp
// Authored by : std-freejia
// Co-authored by : BaaaaaaaaaaarkingDog
// http://boj.kr/f04bee3141834b83b6d1e0a6cd8c59b6
#include <bits/stdc++.h>
using namespace std;

#define X first
#define Y second

int n, m, year;
int area[303][303];
int vis[303][303];

int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};

bool check(int i, int j) {
  return (i >= 0 && i < n && j >= 0 && j < m);
}

void initvis(){
  for(int i = 0; i < n; i++) fill(vis[i], vis[i] + m, 0);
}

// 1ë…„ì˜ ì‹œê°„ íë¦„ì„ ì§„í–‰
void melting(){ 
  int zero[303][303] = {0};
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      if(area[i][j] == 0) continue;
      for(int dir = 0; dir < 4; dir++){ // ì£¼ë³€ì˜ 0ì˜ ê°œìˆ˜ë¥¼ ì„¼ë‹¤
        int nx = i + dx[dir];
        int ny = j + dy[dir];
        if(check(nx, ny) && area[nx][ny] == 0) zero[i][j]++;
      }
    }
  }
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++)
      area[i][j] = max(0, area[i][j] - zero[i][j]);    
  }
}

// 0 : ë¹™ì‚°ì´ ë‹¤ ë…¹ìŒ, 1 : ì•„ì§ í•œ ë©ì´, 2 : ë¶„ë¦¬ë¨
int status(){
  int x = -1, y = -1;
  int cnt1 = 0; // ë¹™ì‚°ì˜ ê°œìˆ˜
  // ë¹™ì‚°ì´ ë‚¨ì•„ìˆëŠ” ì•„ë¬´ ì¹¸ì´ë‚˜ ì„ íƒ
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++){
      if(area[i][j]){
        x = i;
        y = j;
        cnt1++;
      }
    }
  }
  if(cnt1 == 0) return 0; // ë¹™ì‚°ì´ ë‚¨ì•„ìˆëŠ” ì¹¸ì´ ì—†ìŒ
  int cnt2 = 0; // (x, y)ì™€ ë¶™ì–´ìˆëŠ” ë¹™ì‚°ì˜ ìˆ˜
  queue<pair<int,int> > q;
  vis[x][y] = 1; // í˜„ì¬ ìœ„ì¹˜ ë°©ë¬¸
  q.push({x, y});
  while(!q.empty()){
    auto cur = q.front(); q.pop();
    cnt2++;
    for(int i = 0; i < 4; i++){
      int nx = cur.X + dx[i];
      int ny = cur.Y + dy[i];
      if(!check(nx, ny) || vis[nx][ny] == 1 || area[nx][ny] <= 0) continue; // ì •ìƒ ë²”ìœ„, ì²« ë°©ë¬¸, ì´ë™ê°€ëŠ¥ ì²´í¬
      vis[nx][ny] = 1; // ë°©ë¬¸í‘œì‹œ
      q.push({nx, ny}); // ì´ë™
    }
  }
  if(cnt1 == cnt2) return 1; // ì „ì²´ ë¹™ì‚°ì˜ ìˆ˜ì™€ (x, y)ì™€ ë¶™ì–´ìˆëŠ” ë¹™ì‚°ì˜ ìˆ˜ê°€ ì¼ì¹˜í•˜ë¯€ë¡œ ì•„ì§ í•œ ë©ì´
  return 2;
}

int main(void) {
  ios::sync_with_stdio(0);
  cin.tie(0);

  cin >> n >> m;
  for(int i = 0; i < n; i++){
    for(int j = 0; j < m; j++)
      cin >> area[i][j];
  }

  while(true){    
    year++; // 1ë…„ ì¶”ê°€
    melting(); // ë¹™ì‚° ë…¹ì´ê¸°
    initvis(); // ë°©ë¬¸ë°°ì—´ ì´ˆê¸°í™”
    int check = status(); // ë¹™ì‚°ì˜ ìƒíƒœ í™•ì¸
    if(check == 0){
      cout << 0;
      return 0;
    }
    else if(check == 1) continue; // ì•„ì§ í•œ ë©ì´
    else break; // check = 2, ë¶„ë¦¬ë¨
  }
  cout << year;
  return 0;
}

/*
ì´ ì½”ë“œëŠ” O(NM * year)ì— ë™ì‘. ìµœì•…ì˜ ë°ì´í„°ë¥¼ ë„£ì–´ë„ yearê°€ ëŒ€ëµ 500 ì´í•˜ì—¬ì„œ ì‹œê°„ ì´ˆê³¼ê°€ ë°œìƒí•˜ì§€ ì•Šì§€ë§Œ
êµ¬í˜„ì„ í•˜ê¸° ì „ì— ì´ ì½”ë“œì˜ ì‹œê°„ë³µì¡ë„ê°€ ì–¼ë§ˆì¼ì§€, yearê°€ ì–´ë–¤ ê²½ìš°ì— ê°€ì¥ í´ì§€, ê·¸ ê²½ìš° yearëŠ” ì–¼ë§ˆì¼ì§€
ê³ ë¯¼í•´ë³¼ í•„ìš”ê°€ ìˆë‹¤.
*/
```

![image](https://github.com/user-attachments/assets/805342c1-2057-48f8-9e61-d6eeb2f6b455)

ì•„ë˜ ê²ƒì´ ë‚´ ì½”ë“œê³  ìœ„ì˜ ê²ƒì´ ë°”í‚¹ë…ë‹˜ì˜ ì½”ë“œì´ë‹¤. ì‹œê°„ ì°¨ì´ê°€ ë„ˆë¬´ ë§ì´ ë‚˜ì„œ ë‚´ ì½”ë“œë¥¼ ê°œì„ í•˜ê³ ì í•œë‹¤.

# ê°œì„ í•´ì•¼ í•  ì 

**ë¹™í•˜ì™€ ì¸ì ‘í•œ ë¬¼ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì´ ë¹„íš¨ìœ¨ì ì´ë‹¤.**

1. ë‚˜ ê°™ì€ ê²½ìš°ì—ëŠ” bfsë¥¼ í•˜ë©° ëª¨ë“  ì¹¸ì„ íƒìƒ‰í•˜ê³ , ê·¸ ë‹¤ìŒì— ë¬¼ì˜ ê°œìˆ˜ë¥¼ ë°˜ì˜í•œë‹¤.
2. í•˜ì§€ë§Œ ë°”í‚¹ë…ë‹˜ì˜ ì½”ë“œë¥¼ ë³´ë©´ ëª¨ë“  ì¹¸ì„ íƒìƒ‰í•˜ì§€ ì•Šìœ¼ë©° ë¹™í•˜ì¸ ì§€ì ì—ì„œë§Œ ë¬¼ì´ ì–´ëŠì •ë„ ì¸ì ‘í•´ìˆëŠ”ì§€ ê²€ì‚¬í•œë‹¤.

# ê°œì„ í•œ ì½”ë“œ

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;

const int MAX = 300 + 1;

int dirX[4] = {-1, 0, 1, 0};
int dirY[4] = {0, 1, 0, -1};

int map[MAX][MAX];
int visited[MAX][MAX];

int N, M;

bool isValid(int nx, int ny)
{
    if (!(nx < 0 || nx >= MAX || ny < 0 || ny >= MAX)) return true;
    return false;
}

void CalcAdjecentWater2()
{
    int water[MAX][MAX] = {0};
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            // i, jëŠ” í˜„ì¬ ìœ„ì¹˜(ë¹™í•˜). 
            // ë¬¼ì€ ì§€ë‚˜ì¹œë‹¤.
            if (map[i][j] == 0) continue;

            for (int dir = 0; dir < 4; dir++)
            {
                int nx = i + dirX[dir];
                int ny = j + dirY[dir];
                if (isValid(nx, ny) && map[nx][ny] == 0) water[i][j]++;
            }
        }
    }

    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            map[i][j] = max(0, map[i][j] - water[i][j]);
}

void bfs(int x, int y)
{
    queue<pair<int, int>> q;
    q.push({x, y});
    visited[x][y] = 1;

    while (!q.empty())
    {
        pair<int, int> cur = q.front();
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            int nx = cur.first + dirX[i];
            int ny = cur.second + dirY[i];

            if (nx < 0 || nx >= MAX || ny < 0 || ny >= MAX) continue;
            if (visited[nx][ny] == 1 || map[nx][ny] == 0) continue;

            q.push({nx, ny});
            visited[nx][ny] = 1;
        }
    }
}

bool checkZero()
{
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
        {
            if (map[i][j] > 0) return false;
        }
    return true;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    cin >> N >> M;

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            cin >> map[i][j];
        }
    }
    
    int year = 0;
    while (true)
    {
        if (checkZero())
        {
            cout << 0;
            return 0;
        }
        int count = 0;
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < M; j++)
            {
                if (visited[i][j] == 1 || map[i][j] == 0)
                    continue;
                bfs(i, j);
                count++;
            }
        }

        if (count > 1) break;
        
        CalcAdjecentWater2();
        memset(visited, 0, sizeof(visited));
        year++;
    }

    cout << year;
    return 0;
}

```

![image](https://github.com/user-attachments/assets/d52690bd-d1d9-432e-a87c-8cef604823f1)

í•œ ê°€ì§€ë§Œ ê³ ì³¤ëŠ”ë°ë„ í™•ì—°í•˜ê²Œ ì‹œê°„ ì°¨ì´ê°€ ë‚˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤! (ë§¨ ìœ„ì— ìˆëŠ” ì œì¶œì´ ê°œì„ í•œ ì½”ë“œì´ë‹¤.) 

ë¬¸ì œë¥¼ ì•Œê³  ê°œì„ í•˜ë‹ˆ ë°œì „í•˜ëŠ” ëŠë‚Œì´ë¼ ë¿Œë“¯í•˜ë‹¤.