---
title: 2024-12-31 알고리즘 강의 2 정리
date: 2024-12-31
categories: [Etc, TIL]
tags: [TIL]
---
# 변수를 선언한다는 것

```cpp
int val = 7;
```

이렇게 변수를 선언한다는 것은 사실 여러 개의 단계로 나눌 수 있다

1. 메모리 어딘가에 val이라는 변수를 위한 공간을 확보한다.
    1. 예) 메모리 주소  0xabc…에 int 데이터를 넣을 수 있는 공간 확보.
2. 해당 공간에 우리가 저장하고 싶은 데이터를 넣는다.
3. 우리가 붙인 변수 이름으로 해당 메모리 공간을 간접적으로 **참조**한다.

# 포인터의 크기

포인터의 경우에는 포인터 자체의 크기가 **시스템 아키텍처**에 따라 달라진다. 

### 컴퓨터 아키텍처의 주요 요소

1. **CPU 아키텍처**:
    - 프로세서의 설계 방식과 명령어 세트 아키텍처(ISA, Instruction Set Architecture)를 정의한다.
    - 예: x86, ARM, RISC-V 등.
2. **메모리 구조**:
    - 메모리 계층 구조(캐시, RAM, 저장소 등)와 데이터 접근 방식.
3. **주소 공간**:
    - 컴퓨터가 사용할 수 있는 메모리 주소의 범위를 정의.
    - 예: 32비트 아키텍처에서는 최대 4GB 메모리(2³²)까지 접근 가능, 64비트 아키텍처에서는 이론적으로 16엑사바이트(2⁶⁴).
4. **버스 구조**:
    - CPU, 메모리, 주변 장치 간 데이터 전송 방식.
    - 예: PCI, USB, SATA 등.
5. **운영 체제 호환성**:
    - 특정 아키텍처가 어떤 운영 체제와 호환되는지 결정.

### 그 외 정보

32비트 CPU는 64비트 아키텍처에서 동작하지 않는다.

반면, 64비트 CPU는 32비트 아키텍처와 호환될 수 있다.

[아키텍처(Architecture)란 무엇인가? 컴퓨터 아키텍처의 종류와 개념](https://movefun-tech.tistory.com/2)

### 컴퓨터 아키텍처에 따른 포인터 크기

| 컴퓨터 아키텍처(컴퓨터 구조) | 포인터 크기 |
| --- | --- |
| 32비트 | 4바이트 |
| 64비트 | 8바이트 |

왜냐하면, 가리키는 대상이 `int`든 `double`이든, 포인터 자체는 ‘메모리 주소’ 하나를 저장할 공간이면 충분하기 때문이다.

단, 포인터 자체의 크기와는 별개로 포인터 산술 연산을 할 때 타입을 일치시키지 않으면 예기치 않은 버그가 생길 수 있다.

```cpp
// 주의!!! 아래와 같은 코드처럼 이렇게 형변환 하지마세요!
int arr[5] = {1, 2, 3, 4, 5};
double* dp = (double*)arr;  // 위험한 형변환!!!

dp + 1;  // 8바이트 이동
// 원래 int 배열에서는 4바이트씩 이동해야 하는데,
// double 포인터는 8바이트씩 이동하므로 잘못된 메모리 위치를 가리키게 됨
```

# 배열 동적 할당이 안 되는 이유

```cpp
int arr_size;
cin >> arr_size;
int arr[arr_size]; // 안 됨. 
```

이 스택 영역은 **컴파일 시점에 크기가 결정**되어야 하는 메모리 영역이다.

스택 영역은 크기가 제한적인 메모리 영역이다. 실행 시간에 결정되는 크기로 배열을 만들면 스택 오버플로우의 위험이 있다. 그래서, C++은 **컴파일 시점**에 **모든 변수의 크기와 위치가 결정**되어야 한다.

따라서 배열 동적 할당을 하고 싶다면 벡터를 사용하거나 포인터를 이용해야 한다.

# 포인터와 배열의 관계

### 배열 이름은 배열의 **첫 번째 원소의 주소**를 가리키는 **상수 포인터**로 동작한다.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = **arr**; // arr은 &arr[0]과 같아요!

cout << arr[0] << endl;  // 1
cout << *arr << endl; // 1 (arr은 &arr[0]을 가리키니까 *arr은 arr[0]과 동일)
```

위 코드에서 배열 이름 `arr`은 `&arr[0]`과 동일하다. 즉, 배열의 첫 번째 원소를 가리키는 포인터 역할을 하는 것이다.

### **원시 배열을 포인터로 전달할 때는 배열 크기를 별도로 전달해 주어야 한다.**

왜냐하면 배열 자체가 포인터로 처리되기 때문에 크기 정보를 알 수 없기 때문이다.

# 정적 배열 vs 동적 배열

- 정적 배열: 스택 메모리, 컴파일 시점 크기 결정, 자동 해제
- 동적 배열: 힙 메모리, 런타임 크기 결정, 수동 해제

# 참조자 주의

**참조자가 가리키는 대상이 사라진 뒤**(스코프를 벗어났거나 동적 할당 메모리를 해제했거나 등)에도 **참조자를 계속 사용하면 문제**가 생길 수 있다.

```cpp
int& get_ref() {
    int x = 42; // 지역 변수
    return x; // 지역 변수의 참조 반환
}

int main() {
    int& ref = get_ref(); // ref는 소멸한 x를 참조
    std::cout << ref; // 동작을 이상하게 할 수 있음!
}
```

실제로 위의 코드를 실행해보면 42가 출력되는 경우가 대부분이다. 얼핏 봐서는 정상처럼 보이지만 이게 실제론 함수가 반환된 직후에 해당 스택 메모리 위치가 아직 다른 용도로 덮어써지지 않았을 수 있기 때문에 정상처럼 보이는 것이고 이러한 경우가 보장이 안되면 이상 행동을 할 수 있다.

# 언제 포인터를 쓰고 언제 참조자를 쓸까?

**동적 메모리 관리를 해야되거나 재할당을 해야되는게 아니면 → 참조자부터 고려하자!**

# 문제 1

```cpp
int arr[] = {10, 20, 30, 40, 50};
int* ptr = arr;
ptr += 2;
ptr[1] = *ptr + 10; // ptr의 첫 원소는 arr[2]이므로 ptr[1]은 arr[3]이다. 
// 과연 arr의 값은 어떻게 채워져 있을까요?

// {10, 20, 30, 40, 50}
```

# 문제 2

```cpp
void foo(int& x, int* y) {
    x = *y; // a = 20
    *y = 30; // b = 30
    y = &x; // 
    *y = 40; // a = 40
}

int main() {
    int a = 10;
    int b = 20;
		foo(a, &b);
    // a와 b의 최종값은 무엇일까요?
}

// a = 40, b = 30
```
